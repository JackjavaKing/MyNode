##### **一，基本概念**

1，锁是计算机协调多个进程或线程并发访问某一资 源的机制(避免争抢)。
2，在数据库中，除传统的计算资源(如CPU、RAM、I/O等)的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题
3，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

##### 二，锁的分类

（读的时候有印象即可，主要看下面锁的操作这一部分内容来理解锁）

###### 1，从对数据操作的粒度分:

1）表锁：操作时，会锁定整个表。偏向MyISAM存储引擎,开销小,加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高,并发度最低。
2)行锁:操作时，会锁定当前操作行。偏向InnoDB存储引擎，开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
总结：从上述特点可见，很难笼统地说哪种锁更好，只能就具体应用的特点来说哪种锁更合适！仅从锁的角度来说:表级锁更适合于以查询为主,只有少量按索引|条件更新数据的应用，如Web应用;
而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理(OLTP)系统。

###### 2，从对数据操作的类型分:

1)读锁(共享锁) :针对同一份数据，多个读操作可以同时进行而不会互相影响。.
2)写锁(排它锁) :当前操作没有完成之前，它会阻断其他写锁和读锁。
注意：
MyIsam只支持表级锁，innodb既支持表级锁也支持行级锁。

##### 三，锁的操作

1，如何加表锁？

1）MyISAM在执行查询语句(SELECT) 前，会自动给涉及的所有表加读锁，在执行更新操作(UPDATE、DELETE、INSERT等) 前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户-般不需要直接用LOCK TABLE命令给MyISAM表显式加锁。
2）加表锁操作：



    加读锁：lock table table_name read;
    加写锁：lock table table_name write;

比如一般在执行插入的时候，都要先给表申请加写锁，加上以后再修改，修改完以后再释放写锁。
3）表锁的作用：
1–读锁会阻塞其他用户写，但是不会阻塞其他用户读。而写锁，则既会阻塞其他用户读，又会阻塞其他用户写。
2–读锁是共享锁，所有用户都可以加；写锁是排他锁，只有一个用户可以加。
此外，MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。
2，如何加行锁

1，行锁特点：偏向InnoDB 存储引擎,开销大,加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
注意：InnoDB与MylSAM的最大不同有两点: 一是支持事务;二是采用了行级锁。
2，读锁和写锁的功能和表锁一致，只是操作对象不一样。
3，添加行锁的语句：

--读锁（共享锁）：

> SELECT
> ★
> FROM table_name
> WHERE 条件
> LOCK IN SHARE MODE
> --写锁（排他锁）：
> SELECT
> ★
> FROM table_name
> WHERE 条件
> FOR UPDATE