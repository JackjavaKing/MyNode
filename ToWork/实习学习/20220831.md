# 20210831                   		`星期三`

#### java基础知识

1.mysql的主键是默认建立索引的，如果主键是复合主键，支持的是向左原则   如 abc    只有带有a的才会激发索引的机制

2.串行，并行，和并发的区别：并发是指的一个实体在同一时刻**交替**执行任务（宏观也就是同时），并行是指的两个实体**同时**执行任务

> 两者区别
>
> 1. 概念不同
>     并发：并发是指两个或多个事件在**同一时间间隔**发生
>     并行：并行是指两个或者多个事件在**同一时刻**发生。
> 2. 侧重点不同
>     并发侧重于在**同一实体**上
>     并行：并行侧重于在**不同实体**上
> 3. 处理不同
>     并发：并发在**一台处理器**上“同时”处理多个任务。
>     并行：并行在**多台处理器**上同时处理多个任务

3.字节流和字符流的区别

> 1.两者组成不同
> 字节流是由**字节**组成的，而字符流是由**字符**组成的。
> 2.两者结尾不同
> **字节**流以**stream**结尾（如inputStream和outputStream）；而**字符**流以**reader**和**writer**结尾
> 3.两者处理数据的方式不同
>
> 字节流主要用于处理**二进制**数据，它是按**字节**来处理的；而字符流按**虚拟机的encode编码**来处理，也就是要进行**字符集**的转化
> 4.字节流和字符流每次读写的字节数不同：
> 在Java编程语言中，字符由两个字节组成。
> 字符流是块读写，字节流是字节读写；
> 而且**字符流有缓存**，字节流没有。`缓存`
>
> *字节流本身没有缓冲区，缓冲字节流相对于字节流，效率提升非常高。而字符流**本身就带有缓冲区**，缓冲字符流相对于字符流效率提升就不是那么大了。*

4.抽象类实现接口，类继承抽象类，可以避免类直接实现接口造成代码冗余。

> 抽象类是可以实现接口的，-般来说我们使用普通类来实现接口，这个普通类就必须实现接口中所有的方法，这样的结果就是普通类中就需要实现多余的方法,造成代码冗余。  
> 我们使用的是抽象类来实现接口，那么就可以只实现接口中的部分方法,并且当其他类继承这个抽象类时，仍然可以实现接口中有但抽象类并未实现的方法。
> 抽象类只是实现了接口A中的方法a,方法b,但是当类(C继承抽象类B时，可以直接实现接口A中的c方法，有- -点需要注意的是，类C中的方法a,方法b都是调用的父类B的方法a,方法b,不是直接实现的接口的方法a,和方法b

5.b+树优于b树

> b+树的中间节点不保存数据，可以容纳更多的节点元素
> 所有的叶子结点使用链表相连，有助于区间查找和遍历
> B+树的内部节点只存放键，不存放值，因此，一次读取，取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间
>
> B树的话，就需要进行每一层的递归遍历
> 相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好  
>
> #   `树` 

6.![image-20220831090727283](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220831090727283.png)

![image-20220831090737629](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220831090737629.png)

7. 重写和重载的区别

   > 方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的参数列表，有兼容的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。重载对返回类型没有特殊的要求，不能根据返回类型进行区分。

   8. java的异常可以分为一下几种

   > error：错误，无法处理的
   >
   >    Exception：异常，能够被程序本身处理的，可以通过try…catch语句捕捉异常，或者是throws抛出异常。分为运行时异常和非运行时异常。
   >
   > ```java
   > 运行时异常：就是RuntimeException，编译时不会检查出错误的。一般是由于逻辑错误引起的，程序员可以手动去解决的，比如判空等。
   > （受检查时异常，编译异常，非运行时异常 ）非运行时异常：也叫编译异常，就是Exception下除了RuntimeException以外的异常。是必须进行处理的异常，编译器会进行异常提醒的。如果不进行处理，程序编译不通过。
   > ```
   > 

   > ![image-20220831112750481](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220831112750481.png)

8. 实现线程安全的arraylist

   > 写时**CopyOnWriteArrayList**性能较差，且随着数据量的增大，几何级下跌。读操作各方式基本没有区别。
   > **CopyOnWriteArrayList**，适用于以读为主，读操作远远大于写操作的场景中使用，比如缓存。
   > **Collections.synchronizedList**则可以用在**CopyOnWriteArrayList**不适用，但是有需要同步的地方使用， 比如读写操作都比较均匀的地方。
   > 不得不含泪承认，从简单的几次跑数中，**Vector**的读写都很优秀。但既然已经不建议使用，就忘了它吧。

   > CopyOnWriteArrayList
   >
   >         CopyOnWriteArrayList是1.5后引入，属于JUC的一部分。他基本的原理还是和ArrayList一样，涉及线程安全的部分，是通过写时复制的方式来实现（从名字中就可以看出）。它内部有个volatile数组来保持数据。在“添加/修改/删除”数据时，会先获取互斥锁，再新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给volatile数组，然后再释放互斥锁。以get和set为例看看代码。

​	

```
番外：
关于Vector为什么被弃用
    所有方法都有同步开销，非多线程下，效率不如ArrayList；
    一些老代码，导致有重复的方法，以及风格和新的集合类格格不入；
    线程安全的实现，可以通过新的Collections.synchronizedList之类的调用来替换
```

**字符流补充**

> ![image-20220831091049282](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220831091049282.png)
>
>     InputStreamReader：从字节流到字符流的桥梁（InputStreamReader构造器入参是FileInputStream的实例对象），它读取字节并使用指定的字符集将其解码为字符。它使用的字符集可以通过名称指定，也可以显式给定，或者可以接受平台的默认字符集。
>     BufferedReader：从字符输入流中读取文本，设置一个缓冲区来提高效率。BufferedReader是对InputStreamReader的封装，前者构造器的入参就是后者的一个实例对象。
>     FileReader：用于读取字符文件的便利类，new FileReader(File file)等同于new InputStreamReader(new FileInputStream(file, true),"UTF-8")，但FileReader不能指定字符编码和默认字节缓冲区大小。
>     PipedReader ：管道字符输入流。实现多线程间的管道通信。
>     CharArrayReader：从Char数组中读取数据的介质流。
>     StringReader ：从String中读取数据的介质流。
>



#### 前端学习

1. 自定义组件中的收起所触发的函数

![image-20220831093932391](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220831093932391.png)

​	标记的作用没有找到

2. ![image-20220831101104566](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220831101104566.png)



3.自定义组件参数的传递是怎么传的



