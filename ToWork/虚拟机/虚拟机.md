### [类加载器以及双亲委派机制的原理解析](/ToWork/虚拟机/类加载器以及双亲委派机制的原理解析.md)

虚拟机的基本内存结构

![image-20220704194157318](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220704194157318.png)

类的加载过程

![image-20220704195703707](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220704195703707.png)

### 2.什么是沙箱机制？

就是将java代码限定在虚拟机（jvm) 特定的运行范围中，并且严格限制代码对本地系统资源的访问，通过这样的措施来保证对代码的有效隔离，防止对系统造成破坏。

沙箱的组件有类加载器和字节码校验器

* ## jvm运行时数据区的划分?

![image-20220704194157318](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220704194157318.png)

> 1.程序计数器(Program Counter Register)：是一块较小的内存空间，它可以看作是**当前线程所执行的字节码的行号指示器**。
>
> 2.Java虚拟机栈：与程序计数器一样，Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的，它的生命周期与线程相同。
> 虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
> 3.本地方法栈：本地方法栈(Native Method Stack)与虚拟机机所发挥的作用是非常相似的，它们之间的区别不过是虛拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法则为虚拟机使用到的Native方法服务。
> 在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。
> 甚至有的虚拟机(比如Sun Hotspot虚拟机)直接就把本地方法栈和虚拟机栈合二为ー。
>
> 4.Java堆：对于大多数应用来说，Java堆(Java Heap)是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
>
> 此内存区域的唯一目的就是存放对象实例，Java 世界里几乎所有的对象实例都在这里分配内存。
>
> 这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但是随着JT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。
> 5.方法区
>
> 方法区(Method Area)与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
> 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫Non-Heap(非堆)，目的应该是与Java堆区分开来。

* ### 根据jvm规范，这些数据区中哪些会出现 内存溢出异常，分别是什么场景下出现?

  > 什么是内存泄漏和什么是内存溢出 (陌陌)
  >
  > Java存在内存泄漏吗，内存泄漏的场景有哪些，如何避免(百度)
  >
  > Java 中会存在内存泄漏吗，简述一下？(猎聘)
  >
  > 内存泄漏是怎么造成的？(拼多多、字节跳动)
  >
  > 内存泄漏与内存溢出的区别 (字节跳动)
  >
  > Java存在内存溢出的现象吗 (字节跳动)
  >
  > Java中会存在内存泄漏吗，请简单描述。 (美团)



> 1. **java堆溢出（heap）**
>
> **Java堆内存主要用来存放运行过程中所有的对象**，该区域OOM异常一般会有如下错误信息：
>
> java.lang.OutofMemoryError:Java heap space
>
> 可以通过dump的内存快照就能分析，到底是由于程序原因导致的内存泄露，还是由于没有估计好JVM内存的大小而导致的内存溢出。
>
> 2. **栈溢出（stack）**
>
> **栈用来存储线程的局部变量表、操作数栈、动态链接、方法出口等信息。如果请求栈的深度不足时抛出的错误会包含类似下面的信息： java.lang.StackOverflowError。**
>
> 由于每个线程占的内存大概为1M，因此线程的创建也需要内存空间。如果申请创建的线程比较多超过剩余内存的时候，也会抛出如下类似错误：java.lang.OutofMemoryError: unable to create new native thread
> 与栈相关的JVM参数有：
>
> 1、 -Xss: 每个线程的堆栈大小,JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.
>
> 2、 在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对1个进程内的线程数还是有限制的,不能无限生成。
> 出现栈溢出可能原因：
>
> 递归：递归里用到的局部变量存储在堆栈中，堆栈的访问效率高，速度快，但空间有限，递归太多变量需要一直入栈而不出栈，导致需要的内存空间大于堆栈的空间，栈空间是2M，堆空间内存空间。
> **运行时常量溢出（constant）**
>
> 运行时常量保存在**方法区**，存放的主要是编译器生成的各种字面量和符号引用，但是运行期间也可能将新的常量放入池中，比如String类的intern方法。如果该区域OOM，错误结果会包含类似下面的信息：
>
> 1 java.lang.OutofMemoryError: PermGen space
>
> 相关的JVM参数有：
>
> 1、 -XX:PermSize：设置持久代(perm gen)初始值，默认值为物理内存的1/64
>
> 2、 -XX:MaxPermSize：设置持久代最大值，默认为物理内存的1/4
> **方法区溢出**
>
> **方法区主要存储被虚拟机加载的类信息**，如类名、访问修饰符、常量池、字段描述、方法描述等。理论上在JVM启动后该区域大小应该比较稳定，但是目前很多框架，比如Spring和Hibernate等在运行过程中都会动态生成类，因此也存在OOM的风险。如果该区域OOM，错误结果会包含类似下面的信息：
>
> java.lang.OutofMemoryError: PermGen space
>
> 相关的JVM参数有：
>
> 1 -XX:PermSize：设置持久代(perm gen)初始值，默认值为物理内存的1/64
>
> 2 -XX:MaxPermSize：设置持久代最大值，默认为物理内存的1/4

* ###  这些数据区哪些是线程独有的，哪些是线程共享区?

![image-20220712211906541](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20220712211906541.png)

* ### 每个区存储的数据的特点?

  > * **程序计数器**:
  >
  >   程序计数器（Program Counter Register）可以看作是当前线程所执行的`字节码`的行号指示器。
  >
  >   字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
  >
  >   由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一
  >   个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。
  >
  >   如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地
  >    址；如果正在执行的是本地方法，这个计数器值则应为空。
  >
  > * **JVM栈**:
  >
  >   虚拟机栈描述的是`Java方法执行的线程内存模型`：每个方法被执行的时候，Java虚拟机都
  >    会同步创建一个栈帧用于存储`局部变量表、操作数栈、动态连接、方法出口`等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
  >
  > * **堆**：
  >
  >   Java堆（Java Heap）是虚拟机所管理的内存中`最大`的一块，在虚拟机启动的时候创建，是被所有线程共享的区域。
  >
  > java堆的目的是存放`对象实例`，“几乎”所有的对象实例都在堆区分配内存，是`垃圾收集器`管理的内存区域。
  >
  > Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。Java堆既可以被实现成固定大小的，也可以是可扩展的，如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。
  >
  > * **本地方法栈**:
  >
  > 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机
  >  栈为虚拟机执行Java方法服务，而本地方法栈则是为虚拟机使用到的`本地`（Native）方法服务。
  >
  > 本地方法栈是线程私有的。
  >
  > * **方法区**:
  >
  > 方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的`类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据`。
  >
  > 方法区不需要连续的内存，且可以选择固定大小或者可扩展大小。这区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，所以垃圾收集行为在方法区出现比较少。
  >
  > * **运行时常量池**:
  >
  > 运行时常量池是`方法区`的一部分，用于存放编译期生成的各种`字面量与符号引用`，这部分内容将在类加载后存放到方法区的运行时常量池中。
  >
  > 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量
  > 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常
  > 量池，运行期间也可以将新的常量放入池中。

* #### 程序计数器是什么，它是线程独有的吗? 它是否有内存溢出问题.

  > 1.为了能够准确记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器
  >
  > 程序计数器(Program Counter Rerister) 程序计数器是一块内存较小的区域,它用于存储线程的每个执行指令,每个线程都有自己的程序计数器,此区域不会有内存溢出的情况

* #### 虚拟机栈上保存哪些数据?怎么放?虚拟机栈是线程独有的吗，它是否有内存溢出问题?虚拟机栈的优点?

  > 数据：
  >
  > 局部变量表、操作数栈、动态链接、方法出口等信息
  >
  > 
  >
  > 溢出问题：
  >
  > Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。
  >
  > ```java
  > 如果虚拟机采用的是固定大小的Java虚拟机栈，那么每个线程的Java虚拟机栈的容量就可以在线程创立的时候单独选定。如果线程请求分配的容量超过了虚拟机栈允许的容量，那么就会抛出StackOverflowError 异常。
  > 如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出一个 OutOfMemoryError 异常
  > ```
  >
  > 虚拟机栈的优点：
  >
  > 跨平台，指令集小，[编译器](https://so.csdn.net/so/search?q=编译器&spm=1001.2101.3001.7020)容易实现。缺点是性能下降，实现同样的功能需要更多的指令
  >
  > 栈是一种快速有效的分配储存方式，访问速度仅次于程序计数器。
  >
  > JVM堆虚拟机栈的操作只有两个
  >
  > > 每个方法执行，伴随着进栈
  > >
  > > 方法执行结束后，伴随着出栈。



1. 虚拟机栈的大小是否可动?是否会有异常出现?
2. 如何设置虚拟机栈大小?
3. 什么叫本地方法? 是否可以写一个例子来实现本地方法，以输出一个hello world?
4. 什么叫本地方法栈?有什么作用?它是线程私有的吗? 它是否有可能抛出异常?
5. jvm规范一定强制要求实现本地方法栈吗?
6. 方法区是线程独有的吗?它是否有异常?它的作用?
7. 方法区的演进, jdk7及以前，它叫什么? jdk8开始，这又叫什么. 
8. 方法区或永久代的大小如何设置?